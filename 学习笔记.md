## set.c&set.h

- snode是类型为int的链表，symset是其指针，实际使用中该链表疑似带头节点（不保存数据的节点）
- uniteset即把两个两个链表按从小到大顺序插到一起，新分配空间而非原址修改
- setinsert，将一个元素做成链表节点，插入到合适位置
- createset，使用可变参数传参，将一堆int创建为一个链表

- destroyset while free 有一步p->elem = -1000000?不是多此一举？
- inset 在则return 1 否则0

## pl0.c

#### 主程序思路：

1. 初始化变量，进入[getsym](#### getsym)函数调用

#### getsym:

#### getch:

一次读进一行以减少系统函数调用，但是每次函数只会返回下一个字符

相关过程（函数）有getsym()，getch()，其中getch()为获取单个字符的过程，除此之外，它还完成：
（1） 识别且跳过行结束符；
（2） 将输入源文件复写到输出文件；`在此处为stdout`
（3） 产生一份程序列表，输出相应行号或指令计数器的值。`printf("%5d  ", cx); `

#### 变量及enum参照表：

- SYM_IDENTIFIER:识别非到保留字的一般标识符，此标识符值（字符序列）赋给全局量id，而全局量sym 赋值为SYM_IDENTIFIER
- 识别数字序列，当前值赋给全局量NUM，sym 则置为SYM_NUMBER

- 识别:=，<=，>=之类的特殊符号，全局量sym 则分别被赋值为SYM_BECOMES，SYM_LEQ，SYM_GTR 等。

- plus+ minus- times* slash/ lparen( rparen) equ= neq# semicolon; comma, period. GEQLES待补充

